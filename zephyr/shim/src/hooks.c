/* Copyright 2020 The ChromiumOS Authors
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/*
 * TODO(b/272518464): Work around coreboot GCC preprocessor bug.
 * #line marks the *next* line, so it is off by one.
 */
#line 11

#include "common.h"
#include "console.h"
#include "ec_tasks.h"
#include "hook_types.h"
#include "hooks.h"
#include "task.h"
#include "timer.h"

#include <zephyr/kernel.h>

/*
 * TODO(b/272518464): Work around coreboot GCC preprocessor bug.
 * #line marks the *next* line, so it is off by one.
 */
#line 27

#include <ap_power/ap_power.h>
#include <ap_power/ap_power_events.h>

/*
 * hook_registry maps each hook_type to the list of handlers for that hook type.
 *
 * Because this structure is not supported by the usual STRUCT_SECTION_FOREACH,
 * this code must manually generate references to the symbols generated by
 * STRUCT_SECTION_ITERABLE_ALTERNATE in zephyr_hooks_shim.h.
 */
#define HOOK_LIST_EXTERNS(type)                          \
	extern const struct zephyr_shim_hook_info        \
		_zephyr_shim_hook_##type##_list_start[]; \
	extern const struct zephyr_shim_hook_info        \
		_zephyr_shim_hook_##type##_list_end[];
FOR_EACH(HOOK_LIST_EXTERNS, (), HOOK_TYPES_LIST)

#define HOOK_LIST_ENTRY(type)                                   \
	[type] = {                                              \
		.start = _zephyr_shim_hook_##type##_list_start, \
		.end = _zephyr_shim_hook_##type##_list_end,     \
	}
static const struct zephyr_shim_hook_list hook_registry[] = { FOR_EACH(
	HOOK_LIST_ENTRY, (, ), HOOK_TYPES_LIST) };
BUILD_ASSERT(ARRAY_SIZE(hook_registry) == HOOK_TYPE_COUNT,
	     "All defined hook types must be represented in hook_registry");
BUILD_ASSERT(NUM_VA_ARGS_LESS_1(HOOK_TYPES_LIST) + 1 == HOOK_TYPE_COUNT,
	     "At least one hook type is missing from HOOK_TYPES_LIST");

#ifdef CONFIG_PLATFORM_EC_HOOK_SECOND
static void hook_second_work(struct k_work *work);
#endif /* CONFIG_PLATFORM_EC_HOOK_SECOND */
static void hook_tick_work(struct k_work *work);

#ifdef CONFIG_PLATFORM_EC_HOOK_SECOND
static K_WORK_DELAYABLE_DEFINE(hook_seconds_work_data, hook_second_work);
#endif /* CONFIG_PLATFORM_EC_HOOK_SECOND */
static K_WORK_DELAYABLE_DEFINE(hook_ticks_work_data, hook_tick_work);

/* LCOV_EXCL_START informational only; should never happen */
static void work_queue_error(const void *data, int rv)
{
	cprints(CC_HOOK,
		"Warning: deferred call not submitted, "
		"deferred_data=0x%p, err=%d",
		data, rv);
}
/* LCOV_EXCL_STOP */

#ifdef CONFIG_PLATFORM_EC_HOOK_SECOND
static void hook_second_work(struct k_work *work)
{
	int rv;

	hook_notify(HOOK_SECOND);

	rv = k_work_reschedule(&hook_seconds_work_data, K_SECONDS(1));
	/* LCOV_EXCL_START cannot fail unless delay = K_NO_WAIT */
	if (rv < 0)
		work_queue_error(&hook_seconds_work_data, rv);
	/* LCOV_EXCL_STOP */
}
#endif /* CONFIG_PLATFORM_EC_HOOK_SECOND */

static void hook_tick_work(struct k_work *work)
{
	int rv;

	hook_notify(HOOK_TICK);

	rv = k_work_reschedule(&hook_ticks_work_data,
			       K_USEC(HOOK_TICK_INTERVAL));
	/* LCOV_EXCL_START cannot fail unless delay = K_NO_WAIT */
	if (rv < 0)
		work_queue_error(&hook_ticks_work_data, rv);
	/* LCOV_EXCL_STOP */
}

/*
 * Numerically lower priorities take precedence, so verify the hook
 * related threads cannot preempt any of the shimmed tasks.
 */
BUILD_ASSERT(CONFIG_SYSTEM_WORKQUEUE_PRIORITY >= (TASK_ID_COUNT - 1),
	     "System workqueue priority must be lower than all EC tasks");

static int zephyr_shim_setup_hooks(void)
{
	int rv;

#ifdef CONFIG_PLATFORM_EC_HOOK_SECOND
	/* Startup the HOOK_SECOND recurring work */
	rv = k_work_reschedule(&hook_seconds_work_data, K_SECONDS(1));
	/* LCOV_EXCL_START cannot fail unless delay = K_NO_WAIT */
	if (rv < 0)
		work_queue_error(&hook_seconds_work_data, rv);
		/* LCOV_EXCL_STOP */
#endif /* CONFIG_PLATFORM_EC_HOOK_SECOND */

	/* Startup the HOOK_TICK recurring work */
	rv = k_work_reschedule(&hook_ticks_work_data,
			       K_USEC(HOOK_TICK_INTERVAL));
	/* LCOV_EXCL_START cannot fail unless delay = K_NO_WAIT */
	if (rv < 0)
		work_queue_error(&hook_ticks_work_data, rv);
	/* LCOV_EXCL_STOP */

	return 0;
}

SYS_INIT(zephyr_shim_setup_hooks, APPLICATION, 1);

void hook_notify(enum hook_type type)
{
	const struct zephyr_shim_hook_info *start = hook_registry[type].start;
	const struct zephyr_shim_hook_info *end = hook_registry[type].end;
	int last_prio = HOOK_PRIO_FIRST - 1;

	__ASSERT(type >= 0 && type < HOOK_TYPE_COUNT,
		 "hook type %d is out of range (maximum hook_type value %d)",
		 type, HOOK_TYPE_COUNT);

	while (1) {
		/*
		 * Find the lowest priority that is larger than the last pass'
		 * priority. That is, the next highest uncalled priority.
		 */
		int prio = INT_MAX;

		for (const struct zephyr_shim_hook_info *p = start; p != end;
		     p++) {
			__ASSERT(
				IN_RANGE(p->priority, HOOK_PRIO_FIRST,
					 HOOK_PRIO_LAST),
				"Hook priority %d (handler %p) is out of range",
				p->priority, p->routine);
			if (p->priority > last_prio)
				prio = MIN(prio, p->priority);
		}

		if (prio == INT_MAX) {
			/* No more handlers of higher priority */
			break;
		}
		last_prio = prio;

		/* Call each handler with the located priority */
		for (const struct zephyr_shim_hook_info *p = start; p != end;
		     p++) {
			if (p->priority == prio)
				p->routine();
		}
	};
}

int hook_call_deferred(const struct deferred_data *data, int us)
{
	struct k_work_delayable *work = data->work;
	int rv = 0;

	if (us == -1) {
		k_work_cancel_delayable(work);
	} else if (us >= 0) {
		k_timeout_t delay = K_USEC(us);

		rv = k_work_reschedule(work, delay);
		/*
		 * 0 delay for hook_call_deferred is "run as soon as possible",
		 * but Zephyr has no direct equivalent. K_NO_WAIT is the nearest
		 * equivalent, but has additional meaning to Zephyr work
		 * scheduling that can cause scheduling to fail depending on
		 * the work item's current state. hook_call_deferred never
		 * fails unless the given deferred_data is invalid, in contrast.
		 *
		 * To prevent spurious failure, if the numeric value we were
		 * given happens to become K_NO_WAIT (at the time of writing,
		 * K_NO_WAIT is zero) and the reschedule attempt fails as a
		 * result, then instead request a minimum delay.
		 */
		if (rv == -EBUSY && K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
			rv = k_work_reschedule(work, K_TICKS(1));
		}

		/*
		 * LCOV_EXCL_START k_work_reschedule only returns errors
		 * if queue is stopped or unspecified, and the system
		 * never does either of those.
		 */
		if (rv < 0) {
			work_queue_error(data, rv);
		}
		/* LCOV_EXCL_STOP */
	} else {
		return EC_ERROR_PARAM2; /* LCOV_EXCL_LINE caller misuse */
	}

	return rv >= 0 ? EC_SUCCESS : rv;
}

/*
 * Shims for interconnecting AP power sequence events with legacy hooks.
 * Depending on whether the power sequence code is running in zephyr or
 * not, a shim is setup to send events either from the legacy hooks to
 * the AP power event callbacks, or vice versa.
 */
#if defined(CONFIG_AP_PWRSEQ) && !defined(CONFIG_EMUL_AP_PWRSEQ_DRIVER)

/*
 * Callback handler, dispatch to hooks
 */
static void ev_handler(struct ap_power_ev_callback *cb,
		       struct ap_power_ev_data data)
{
	switch (data.event) {
	/*
	 * LCOV_EXCL_START unreachable case unless ap_power_ev_init_callback()
	 * below adds an event without adding a case here.
	 */
	default:
		break;
		/* LCOV_EXCL_STOP */

#define CASE_HOOK(h)                           \
	case AP_POWER_##h:                     \
		hook_notify(HOOK_CHIPSET_##h); \
		break

		CASE_HOOK(PRE_INIT);
		CASE_HOOK(STARTUP);
		CASE_HOOK(RESUME);
		CASE_HOOK(SUSPEND);
#if CONFIG_PLATFORM_EC_CHIPSET_RESUME_INIT_HOOK
		CASE_HOOK(RESUME_INIT);
		CASE_HOOK(SUSPEND_COMPLETE);
#endif
		CASE_HOOK(SHUTDOWN);
		CASE_HOOK(SHUTDOWN_COMPLETE);
		CASE_HOOK(HARD_OFF);
		CASE_HOOK(RESET);
	}
}

/*
 * Events are received from the AP power event system and sent to the hooks.
 */
static int zephyr_shim_ap_power_event(void)
{
	static struct ap_power_ev_callback cb;

	/*
	 * Register for all events.
	 */
	ap_power_ev_init_callback(
		&cb, ev_handler,
		AP_POWER_PRE_INIT | AP_POWER_STARTUP | AP_POWER_RESUME |
			AP_POWER_SUSPEND |
#if CONFIG_PLATFORM_EC_CHIPSET_RESUME_INIT_HOOK
			AP_POWER_RESUME_INIT | AP_POWER_SUSPEND_COMPLETE |
#endif
			AP_POWER_SHUTDOWN | AP_POWER_SHUTDOWN_COMPLETE |
			AP_POWER_HARD_OFF | AP_POWER_RESET);
	ap_power_ev_add_callback(&cb);
	return 0;
}

SYS_INIT(zephyr_shim_ap_power_event, APPLICATION, 1);
#else /* !CONFIG_AP_PWRSEQ */

/*
 * Events received from the hooks and sent to the AP power event callbacks.
 */
#define EV_HOOK(h)                                        \
	static void hook_##h(void)                        \
	{                                                 \
		ap_power_ev_send_callbacks(AP_POWER_##h); \
	}                                                 \
	DECLARE_HOOK(HOOK_CHIPSET_##h, hook_##h, HOOK_PRIO_DEFAULT)

EV_HOOK(PRE_INIT);
EV_HOOK(STARTUP);
EV_HOOK(RESUME);
EV_HOOK(SUSPEND);
#if CONFIG_PLATFORM_EC_CHIPSET_RESUME_INIT_HOOK
EV_HOOK(RESUME_INIT);
EV_HOOK(SUSPEND_COMPLETE);
#endif
EV_HOOK(SHUTDOWN);
EV_HOOK(SHUTDOWN_COMPLETE);
EV_HOOK(HARD_OFF);
EV_HOOK(RESET);
#endif /* !CONFIG_AP_PWRSEQ */
